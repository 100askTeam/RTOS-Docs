import{_ as o,r as d,o as h,c as l,a as e,b as t,d as r,w as s,e as p}from"./app-a3aa5aa8.js";const c={},n=p('<h1 id="第一章-freertos概述与体验" tabindex="-1"><a class="header-anchor" href="#第一章-freertos概述与体验" aria-hidden="true">#</a> 第一章 FreeRTOS概述与体验</h1><h2 id="_1-1-freertos目录结构" tabindex="-1"><a class="header-anchor" href="#_1-1-freertos目录结构" aria-hidden="true">#</a> 1.1 FreeRTOS目录结构</h2><p>以Keil工具下STM32F103芯片为例，它的FreeRTOS的目录如下:</p><p><img src="http://photos.100ask.net/rtos-docs/FreeRTOS/simulator/chapter-1/01_dir_file.png" alt="image-20210727184941737"></p><p>主要涉及2个目录：</p><ul><li>Demo <ul><li>Demo目录下是工程文件，以&quot;芯片和编译器&quot;组合成一个名字</li><li>比如：CORTEX_STM32F103_Keil</li></ul></li><li>Source <ul><li>根目录下是核心文件，这些文件是通用的</li><li>portable目录下是移植时需要实现的文件 <ul><li>目录名为：[compiler]/[architecture]</li><li>比如：RVDS/ARM_CM3，这表示cortexM3架构在RVDS工具上的移植文件</li></ul></li></ul></li></ul><h2 id="_1-2-核心文件" tabindex="-1"><a class="header-anchor" href="#_1-2-核心文件" aria-hidden="true">#</a> 1.2 核心文件</h2><p>FreeRTOS的最核心文件只有2个：</p><ul><li>FreeRTOS/Source/tasks.c</li><li>FreeRTOS/Source/list.c</li></ul><p>其他文件的作用也一起列表如下：</p><table><thead><tr><th>FreeRTOS/Source/下的文件</th><th>作用</th></tr></thead><tbody><tr><td>tasks.c</td><td>必需，任务操作</td></tr><tr><td>list.c</td><td>必须，列表</td></tr><tr><td>queue.c</td><td>基本必需，提供队列操作、信号量(semaphore)操作</td></tr><tr><td>timer.c</td><td>可选，software timer</td></tr><tr><td>event_groups.c</td><td>可选，提供event group功能</td></tr><tr><td>croutine.c</td><td>可选，过时了</td></tr></tbody></table><h2 id="_1-3-移植时涉及的文件" tabindex="-1"><a class="header-anchor" href="#_1-3-移植时涉及的文件" aria-hidden="true">#</a> 1.3 移植时涉及的文件</h2><p>移植FreeRTOS时涉及的文件放在<code>FreeRTOS/Source/portable/[compiler]/[architecture]</code>目录下，</p><p>比如：RVDS/ARM_CM3，这表示cortexM3架构在RVDS或Keil工具上的移植文件。</p><p>里面有2个文件：</p><ul><li>port.c</li><li>portmacro.h</li></ul><h2 id="_1-4-头文件相关" tabindex="-1"><a class="header-anchor" href="#_1-4-头文件相关" aria-hidden="true">#</a> 1.4 头文件相关</h2><h3 id="_1-4-1-头文件目录" tabindex="-1"><a class="header-anchor" href="#_1-4-1-头文件目录" aria-hidden="true">#</a> 1.4.1 头文件目录</h3><p>FreeRTOS需要3个头文件目录：</p><ul><li>FreeRTOS本身的头文件：FreeRTOS/Source/include</li><li>移植时用到的头文件：FreeRTOS/Source/portable/[compiler]/[architecture]</li><li>含有配置文件FreeRTOSConfig.h的目录</li></ul><h3 id="_1-4-2-头文件" tabindex="-1"><a class="header-anchor" href="#_1-4-2-头文件" aria-hidden="true">#</a> 1.4.2 头文件</h3><p>列表如下：</p><table><thead><tr><th>头文件</th><th>作用</th></tr></thead><tbody><tr><td>FreeRTOSConfig.h</td><td>FreeRTOS的配置文件，比如选择调度算法：configUSE_PREEMPTION<br>每个demo都必定含有FreeRTOSConfig.h<br>建议去修改demo中的FreeRTOSConfig.h，而不是从头写一个</td></tr><tr><td>FreeRTOS.h</td><td>使用FreeRTOS API函数时，必须包含此文件。<br>在FreeRTOS.h之后，再去包含其他头文件，比如：<br>task.h、queue.h、semphr.h、event_group.h</td></tr></tbody></table><h2 id="_1-5-内存管理" tabindex="-1"><a class="header-anchor" href="#_1-5-内存管理" aria-hidden="true">#</a> 1.5 内存管理</h2><p>文件在<code>FreeRTOS/Source/portable/MemMang</code>下，它也是放在<code>portable</code>目录下，表示你可以提供自己的函数。</p><p>源码中默认提供了5个文件，对应内存管理的5种方法。</p>',26),u={href:"https://blog.csdn.net/qq_43212092/article/details/104845158",target:"_blank",rel:"noopener noreferrer"},_=p('<p>后续章节会详细讲解。</p><table><thead><tr><th>文件</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>heap_1.c</td><td>分配简单，时间确定</td><td>只分配、不回收</td></tr><tr><td>heap_2.c</td><td>动态分配、最佳匹配</td><td>碎片、时间不定</td></tr><tr><td>heap_3.c</td><td>调用标准库函数</td><td>速度慢、时间不定</td></tr><tr><td>heap_4.c</td><td>相邻空闲内存可合并</td><td>可解决碎片问题、时间不定</td></tr><tr><td>heap_5.c</td><td>在heap_4基础上支持分隔的内存块</td><td>可解决碎片问题、时间不定</td></tr></tbody></table><h2 id="_1-6-demo" tabindex="-1"><a class="header-anchor" href="#_1-6-demo" aria-hidden="true">#</a> 1.6 Demo</h2><p>Demo目录下是预先配置好的、没有编译错误的工程。目的是让你可以基于它进行修改，以适配你的单板。</p><p>这些Demo还可以继续精简：</p><ul><li><code>Demo/Common</code>中的文件可以完全删除</li><li>main函数中只需要保留2个函数： <ul><li>prvSetupHardware()</li><li>vTaskStartScheduler()</li><li>如下图所示</li></ul></li></ul><p><img src="http://photos.100ask.net/rtos-docs/FreeRTOS/simulator/chapter-1/02_simple_main.c.png" alt="image-20210727193404198"></p><h2 id="_1-7-数据类型和编程规范" tabindex="-1"><a class="header-anchor" href="#_1-7-数据类型和编程规范" aria-hidden="true">#</a> 1.7 数据类型和编程规范</h2><h3 id="_1-7-1-数据类型" tabindex="-1"><a class="header-anchor" href="#_1-7-1-数据类型" aria-hidden="true">#</a> 1.7.1 数据类型</h3><p>每个移植的版本都含有自己的<code>portmacro.h</code>头文件，里面定义了2个数据类型：</p><ul><li>TickType_t： <ul><li>FreeRTOS配置了一个周期性的时钟中断：Tick Interrupt</li><li>每发生一次中断，中断次数累加，这被称为tick count</li><li>tick count这个变量的类型就是TickType_t</li><li>TickType_t可以是16位的，也可以是32位的</li><li>FreeRTOSConfig.h中定义configUSE_16_BIT_TICKS时，TickType_t就是uint16_t</li><li>否则TickType_t就是uint32_t</li><li>对于32位架构，建议把TickType_t配置为uint32_t</li></ul></li><li>BaseType_t： <ul><li>这是该架构最高效的数据类型</li><li>32位架构中，它就是uint32_t</li><li>16位架构中，它就是uint16_t</li><li>8位架构中，它就是uint8_t</li><li>BaseType_t通常用作简单的返回值的类型，还有逻辑值，比如<code>pdTRUE/pdFALSE</code></li></ul></li></ul><h3 id="_1-7-2-变量名" tabindex="-1"><a class="header-anchor" href="#_1-7-2-变量名" aria-hidden="true">#</a> 1.7.2 变量名</h3><p>变量名有前缀：</p><table><thead><tr><th>变量名前缀</th><th>含义</th></tr></thead><tbody><tr><td>c</td><td>char</td></tr><tr><td>s</td><td>int16_t，short</td></tr><tr><td>l</td><td>int32_t，long</td></tr><tr><td>x</td><td>BaseType_t，<br>其他非标准的类型：结构体、task handle、queue handle等</td></tr><tr><td>u</td><td>unsigned</td></tr><tr><td>p</td><td>指针</td></tr><tr><td>uc</td><td>uint8_t，unsigned char</td></tr><tr><td>pc</td><td>char指针</td></tr></tbody></table><h3 id="_1-7-3-函数名" tabindex="-1"><a class="header-anchor" href="#_1-7-3-函数名" aria-hidden="true">#</a> 1.7.3 函数名</h3><p>函数名的前缀有2部分：返回值类型、在哪个文件定义。</p><table><thead><tr><th>函数名前缀</th><th>含义</th></tr></thead><tbody><tr><td>vTaskPrioritySet</td><td>返回值类型：void<br>在task.c中定义</td></tr><tr><td>xQueueReceive</td><td>返回值类型：BaseType_t<br>在queue.c中定义</td></tr><tr><td>pvTimerGetTimerID</td><td>返回值类型：pointer to void<br>在tmer.c中定义</td></tr></tbody></table><h3 id="_1-7-4-宏的名" tabindex="-1"><a class="header-anchor" href="#_1-7-4-宏的名" aria-hidden="true">#</a> 1.7.4 宏的名</h3><p>宏的名字是大小，可以添加小写的前缀。前缀是用来表示：宏在哪个文件中定义。</p><table><thead><tr><th>宏的前缀</th><th>含义：在哪个文件里定义</th></tr></thead><tbody><tr><td>port (比如portMAX_DELAY)</td><td>portable.h或portmacro.h</td></tr><tr><td>task (比如taskENTER_CRITICAL())</td><td>task.h</td></tr><tr><td>pd (比如pdTRUE)</td><td>projdefs.h</td></tr><tr><td>config (比如configUSE_PREEMPTION)</td><td>FreeRTOSConfig.h</td></tr><tr><td>err (比如errQUEUE_FULL)</td><td>projdefs.h</td></tr></tbody></table><p>通用的宏定义如下：</p><table><thead><tr><th>宏</th><th>值</th></tr></thead><tbody><tr><td>pdTRUE</td><td>1</td></tr><tr><td>pdFALSE</td><td>0</td></tr><tr><td>pdPASS</td><td>1</td></tr><tr><td>pdFAIL</td><td>0</td></tr></tbody></table><h2 id="_1-8-安装keil" tabindex="-1"><a class="header-anchor" href="#_1-8-安装keil" aria-hidden="true">#</a> 1.8 安装Keil</h2><p>本教程的所有程序，都是使用Keil开发，运行在Keil的模拟器上。</p><h3 id="_1-8-1-下载keil" tabindex="-1"><a class="header-anchor" href="#_1-8-1-下载keil" aria-hidden="true">#</a> 1.8.1 下载Keil</h3><p>Keil-MDK（Keil ARM Microcontroller Development Kit）前生是德国Keil公司，后被ARM收购，是ARM官方的集成开发环境。</p><p>打开Keil官网（https://www.keil.com/download/product/），点击“MDK-Arm”进行下载。</p><p><img src="http://photos.100ask.net/rtos-docs/FreeRTOS/simulator/chapter-1/03_download_MDK.png" alt="image-20210727193404198"></p><p>随后进入个人信息完善页面，按提示填写所有的信息，如下图所示，填写完后，点击“Submit”提交。</p><p><img src="http://photos.100ask.net/rtos-docs/FreeRTOS/simulator/chapter-1/04_submit.png" alt="image-20210727193404198"></p><p>随后进入下载页面，点击“MDK532.EXE”即可下载。</p><p><img src="http://photos.100ask.net/rtos-docs/FreeRTOS/simulator/chapter-1/05_MDK532.png" alt="image-20210727193404198"></p><h3 id="_1-8-2-安装keil" tabindex="-1"><a class="header-anchor" href="#_1-8-2-安装keil" aria-hidden="true">#</a> 1.8.2 安装Keil</h3><p>下载完后，点击运行该文件，进入安装界面，选择“Next &gt;&gt;”。</p><p><img src="http://photos.100ask.net/rtos-docs/FreeRTOS/simulator/chapter-1/06_setup1.png" alt="image-20210727193404198"></p><p>接着进入用户协议界面，勾选同意协议，点击“Next &gt;&gt;”。</p><p><img src="http://photos.100ask.net/rtos-docs/FreeRTOS/simulator/chapter-1/07_setup2.png" alt="image-20210727193404198"></p><p>然后设置安装路径，如下图所示：</p><ul><li><p>第一个“Core”是软件的安装路径，</p></li><li><p>第二个“Pack”是芯片的硬件支持包的安装路径，</p></li></ul><p>保持默认路径或者设置为如下图所示一样的即可。</p><p>如果是自定义设置，建议为全英文路径，<strong>不建议为包含有中文的路径</strong>。</p><p>选择好之后点击“Next &gt;&gt;”。</p><p><img src="http://photos.100ask.net/rtos-docs/FreeRTOS/simulator/chapter-1/08_setup3.png" alt="image-20210727193404198"></p><p>随后需要设置个人信息，随便填写即可，如下图所示。</p><p><img src="http://photos.100ask.net/rtos-docs/FreeRTOS/simulator/chapter-1/09_setup4.png" alt="image-20210727193404198"></p><p>之后便进入安装进度界面，等待安装完成。</p><p>安装过程中，回弹出驱动安装界面，勾选“始终信任来自‘ARM Ltd’的软件”，然后点击“安装”，如下图。</p><p><img src="http://photos.100ask.net/rtos-docs/FreeRTOS/simulator/chapter-1/10_setup5.png" alt="image-20210727193404198"></p><p>之后会自动进入“Pack Installer”界面，这里会检查安装的编译器、CMSIS等是否是最新的，由于我们安装的是官网提供的最新的MDK，所以这里一般情况下都是不需要更新的。</p><h3 id="_1-8-3-安装pack" tabindex="-1"><a class="header-anchor" href="#_1-8-3-安装pack" aria-hidden="true">#</a> 1.8.3 安装Pack</h3><p>一个Keil的开发环境，除了Keil软件，还需要安装对应的Pack。</p><p>比如这里目标机的MCU是STM32F103ZET6，就需要下载该系列的的Pack，如果是STM32F4系列，就需要下其它系列Pack。</p><p>使用“Pack Installer”可以方便的对Pack安装和管理。</p><p>在左上角搜索框输入“STM32F103”，展开搜索结果，可以看到STM32F103ZE，点击右边的简介链接即可跳转到Pack下载页面。</p><p><img src="http://photos.100ask.net/rtos-docs/FreeRTOS/simulator/chapter-1/11_setup6.png" alt="image-20210727193404198"></p><p><img src="http://photos.100ask.net/rtos-docs/FreeRTOS/simulator/chapter-1/12_setup7.png" alt="image-20210727193404198"></p><p>下载完成得到“Keil.STM32F1xx_DFP.2.3.0.pack”。</p><p>直接双击该文件，随后弹出如下图所示界面，点击“Next”进行安装。</p><p><img src="http://photos.100ask.net/rtos-docs/FreeRTOS/simulator/chapter-1/13_setup8.png" alt="image-20210727193404198"></p><p>至此，Keil和Pack就安装完成了。</p><h2 id="_1-9-使用模拟器运行第1个程序" tabindex="-1"><a class="header-anchor" href="#_1-9-使用模拟器运行第1个程序" aria-hidden="true">#</a> 1.9 使用模拟器运行第1个程序</h2><p>先获取配套示例代码。</p><p>双击&quot;FreeRTOS_01_create_task\\FreeRTOS\\Demo\\CORTEX_STM32F103_Keil\\RTOSDemo.uvprojx&quot;打开第一个示例。</p><p>打开之后，首先要<strong>编译工程</strong>，才能使用模拟器运行，点击&quot;Build&quot;图标进行编译，如下图所示：</p><p><img src="http://photos.100ask.net/rtos-docs/FreeRTOS/simulator/chapter-1/14_build_RTOSDemo.png" alt="image-20210727193404198"></p><p>编译完成后，点击&quot;Debug&quot;按钮进行仿真，如下图所示：</p><p><img src="http://photos.100ask.net/rtos-docs/FreeRTOS/simulator/chapter-1/15_debug_RTOSDemo.png" alt="image-20210727193404198"></p><p>第一个程序里面创建了两个任务，两个任务一直打印各自的信息。</p><p>这里需要打开串口显示模拟窗口，显示任务的打印内容。</p><p>点击左上角菜单的“View”，然后选择“Serial Windows”，点击“UART #1”，如下图所示：</p><p><img src="http://photos.100ask.net/rtos-docs/FreeRTOS/simulator/chapter-1/16_debug_Uart1.png" alt="image-20210727193404198"></p><p>最后，点击“Run”运行程序，右下角串口显示窗口将打印两个任务的信息。</p><p><img src="http://photos.100ask.net/rtos-docs/FreeRTOS/simulator/chapter-1/17_debug_Run.png" alt="image-20210727193404198"></p><p>如果想退出模拟器仿真，再次&quot;Debug&quot;按钮退出，如下图所示：</p><p><img src="http://photos.100ask.net/rtos-docs/FreeRTOS/simulator/chapter-1/22_exit_debug.png" alt="image-20210810071038121"></p><h2 id="_1-10-使用逻辑分析仪" tabindex="-1"><a class="header-anchor" href="#_1-10-使用逻辑分析仪" aria-hidden="true">#</a> 1.10 使用逻辑分析仪</h2><p>本课程的程序有两种输出方式：</p><ul><li>串口：查看打印信息</li><li>逻辑分析仪：观察全局变量的波形，根据波形解析任务调度情况</li></ul><p>下面举例说明逻辑分析仪的用法。</p><p>双击&quot;FreeRTOS_06_taskdelay\\FreeRTOS\\Demo\\CORTEX_STM32F103_Keil\\RTOSDemo.uvprojx&quot;打开该示例。</p><p>打开之后，首先要<strong>编译工程</strong>，点击&quot;Build&quot;图标进行编译。</p><p>编译完成后，点击&quot;Debug&quot;按钮进行仿真。</p><p>本实例使用模拟器的逻辑分析仪观察现象。</p><p>首先在“main.c”的主函数加入断点，在代码行前的灰色处，点击一下就会有一个红色小点，就是设置的“断点”。</p><p><img src="http://photos.100ask.net/rtos-docs/FreeRTOS/simulator/chapter-1/18_debug_Point.png" alt="image-20210727193404198"></p><p>然后点击“Run”运行，程序运行到断点位置，就会停下来等待下一步操作：</p><ul><li><p>在代码中找到全局变量flag</p></li><li><p>鼠标选中flag，然后点击鼠标右键，在弹出的菜单里选择&quot;Add ‘flag’ to…&quot;，选择“Analyzer”，</p><p>如下图所示：</p></li></ul><p><img src="http://photos.100ask.net/rtos-docs/FreeRTOS/simulator/chapter-1/19_debug_Analyzer.png" alt="image-20210727193404198"></p><p>此时在代码框上面，就会出现逻辑分析仪“Logic Analyzer”显示窗口，里面分析的就是变量flag。</p><p>点击这个flag，然后右键，选择“Bit”，以便观察，如下图所示：</p><p><img src="http://photos.100ask.net/rtos-docs/FreeRTOS/simulator/chapter-1/20_debug_Bit.png" alt="image-20210727193404198"></p><p>再点击一下“Run”，继续运行，此时逻辑分析仪窗口显示变量flag的bit值变化，如下图所示：</p><p><img src="http://photos.100ask.net/rtos-docs/FreeRTOS/simulator/chapter-1/21_debug_Analyzer_Show.png" alt="image-20210727193404198"></p><p>在逻辑分析仪窗口，可以使用鼠标滚轮放大、缩小波形。</p><h2 id="技术答疑交流" tabindex="-1"><a class="header-anchor" href="#技术答疑交流" aria-hidden="true">#</a> 技术答疑交流</h2>',95),m={href:"https://forums.100ask.net",target:"_blank",rel:"noopener noreferrer"},g=e("hr",null,null,-1);function T(S,b){const a=d("ExternalLinkIcon"),i=d("center");return h(),l("div",null,[n,e("p",null,[t("参考文章："),e("a",u,[t("FreeRTOS说明书吐血整理【适合新手+入门】"),r(a)])]),_,e("p",null,[t("在学习中遇到任何问题，请前往我们的技术交流社区留言： "),e("a",m,[t("https://forums.100ask.net"),r(a)])]),g,r(i,null,{default:s(()=>[t("本章完")]),_:1})])}const k=o(c,[["render",T],["__file","chapter1.html.vue"]]);export{k as default};
